# 四、图的应用

## 4.1 最小生成树(MST)

对于一个带权连通无向图G=(V,E)，生成树不同，每棵树的权值可能不同，设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树

获取最小生成树有两种算法：

①Prim算法

从某个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止

时间复杂度为$O(|V^2|)$适用于边稠密图

②Kruskal算法

每次选择一条权值最小的边，使这两条边两头连通，直到所有的结点都连通

时间复杂度为$O(|Elog_2|E||)$适用于边稀疏图



## 4.2 最短路径

### 4.2.1 Dijkstra算法

Dijkstra算法适用于单源最短路径，需要数组dist[]最小路径长度和path[]路径前驱

思想：循环遍历所有结点，找到还没确定的最短路径

时间复杂度为$O(|V^2|)$不适合带有负权值的带权图



### 4.2.2 Floyd算法

Floyd算法适用于各顶点之间的最短路径

伪代码如下：

若$A^{k-1}[i][j]>A^{k-1}[i][k]+A^{k-1}[k][j]$

则$A^{k}[i][j]=A^{k-1}[j][k]+A^{k-1}[k][j]$

$path^k[i][j]=k$

其中A为邻接矩阵，path的初始值设为-1

时间复杂度为$O(|V^3|)$，空间复杂度为$O(|V|^2)$

Floyd可以解决带有负权值的带权图，但不能解决带有负权回路的图



## 4.3 有向无环图(DAG)

有向无环图：若一个图中不存在环，则称为有向无环图

应用：二叉树中，相同部分可以合并



## 4.4 拓补排序(AOV网)

**若有向图的顶点不能构成一个拓补序列，则判定是一个强连通图**

1. 从AOV网中选择一个入度为0的顶点并输出
2. 从网中删除该顶点和所有以它为终点的边
3. 重复1和2直到当前的AOV网为空

~~~C
bool TopologicalSort(Graph G){
    InitStack(S);
    for(int i=0; i<G.vexnum; i++)
        if(indegree[i]==0) Push(S,i); //将入度为0的顶点入栈
    int count = 0;
    while(!isEmpty(S)){
        Pop(S,i);
        print[count++]=i;
        for(p=G.vertices[i].firstarc;p;p->nextarc){
            // 将所有指向顶点入度减一，并将入度为0的顶点压入栈s
            v=p->adjvex;
            if(!(--indegree[v])) Push(S,v)
        }
    }
    if (count<G.vexnum) return false;
    else return true;
}
~~~

**若一个顶点已经排在一个线性有序的序列，每个顶点有唯一的后继关系，只有在这种情况下，拓补排序是唯一的，并且对于一般的图，如果其邻接矩阵是三角矩阵，则一定存在拓补序列，反之不成立**



## 4.5 关键路径(AOE网)

以顶点表示事件，以有向边表示活动，以边上的权值表示活动的开销

1. 只有在某顶点的所代表事件发生后，从该顶点出发的各有向边所代表活动才能开始
2. 只有在进入某顶点的各有向边所代表的活动都已经结束后，该顶点代表的事件才能开始

**在AOE网中仅有一个入度为0的顶点，也只有一个出度为0的顶点**

从源点到汇点的所有路径中，具有最大路径称为关键路径

求关键路径的步骤：

1. 求所有事件发生的最早发生时间：按拓补排序序列求时间v~k~的最早发生时间ve(k)
2. 求所有时间的最迟发生时间：按逆拓补序列，求时间v~k~的最迟发生时间vl(k)
3. 求所有活动最早发生时间：活动a~i~最早开始时间e(i)=ve(k)
4. 求所有活动最迟发生时间：活动a~i~最迟开始时间l(i)=vl(i)-weight(v~k~-v~i~)
5. 求时间余量d()，d(i)=0的活动称为关键活动，由关键活动组成的路径即为关键路径